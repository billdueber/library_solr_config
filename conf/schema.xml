<?xml version="1.0" encoding="UTF-8" ?>


<!DOCTYPE schema [

    <!--  =====================================================
          LOCAL FIELD DEFINITIONS, DYNAMIC FIELDS,
          ETC.
          =====================================================

          If you want to keep this generic setup separate from
          your core-specific stuff, you might want to keep
          them in loaded files outside of this git repo.

          By default, we load them up from schema/local_explicit_fields.xml,
          schema/local_fieldtypes.xml, and schema/local_dynamic_fields.xml, all
          of which are shipped as empty.

          You can edit those files directly, or change the below
          paths to something else.

          Entity expansion in XML is *not* order-dependent, so you can
          use any of the entities declared here in the local files.

          KEEP IN MIND that if you want to override any of the
          basic field types (e.g., 'text') you need to eliminate them
          from the shipped config OR replace them via the
          schema API (which this whole thing should be switched to...)
       -->

    <!ENTITY local_fieldtypes SYSTEM "schema/local_fieldtypes.xml">
    <!ENTITY local_explicit_fields SYSTEM "schema/local_explicit_fields.xml">
    <!ENTITY local_dynamic_fields SYSTEM "schema/local_dynamic_fields.xml">

    <!-- Which stemmer to use when using a stemmer? If you set this to the
         empty string, no stemming will happen even where it normally would
    -->

    <!-- <!ENTITY stem '&stem_with_porter_stemmer;'> -->
    <!ENTITY stem '&stem_with_kstemmer;'>

    <!-- Definition of the required ID type -->
    <!ENTITY id_type 'string'>
    <!ENTITY id_stored 'true'>

    <!-- ======================================================
         END OF THE STUFF YOU WOULD NORMALLY EDIT
         ====================================================== -->



    <!-- basic, primative types (int, float, string, etc.) -->
    <!ENTITY primative_types SYSTEM "schema/primative_types.xml">

    <!-- Constants -->
    <!ENTITY nbsp "&#160;"> <!-- non-breaking space -->
    <!ENTITY zwsp "&#x200B;">
    <!ENTITY pig '10000'> <!-- position increment gap -->

    <!-- Changes at the character level -->
    <!ENTITY pre_tokenization_character_substitution '
      <charFilter class="solr.MappingCharFilterFactory" mapping="schema/character_and_symbol_substitutions.txt"/>
    '>
    <!ENTITY normalize_numeric_digits '
      <filter class="solr.DecimalDigitFilterFactory"/>
    '>

    <!ENTITY spaceify_dash_and_colon '
      <filter class="solr.PatternReplaceFilterFactory"
               pattern="([:\-])" replacement=" " replace="all"
      />
    '>


    <!-- Ways to ditch stuff -->

    <!ENTITY trim_leading_and_trailing_whitespace '
      <filter class="solr.TrimFilterFactory"/>
    '>

    <!ENTITY remove_all_numbers '
      <filter class="solr.PatternReplaceFilterFactory" pattern="[\p{N}]" replacement="" replace="all"/>
    '>

    <!ENTITY remove_all_non_numbers '
      <filter class="solr.PatternReplaceFilterFactory" pattern="[^\p{N}]" replacement="" replace="all"/>
    '>

    <!ENTITY remove_all_non_letters '
      <filter class="solr.PatternReplaceFilterFactory" pattern="[^\p{L}]" replacement="" replace="all"/>
    '>

    <!ENTITY remove_all_punctuation '
      <filter class="solr.PatternReplaceFilterFactory" pattern="[\p{P}]" replacement="" replace="all"/>
    '>

    <!-- stemming -->
    <!-- KStem lists taken from http://lexicalresearch.com/software.html -->
    <!-- Note we don't need to pull in the headwords, since they're hardcoded (!) in.
         See the eight files at https://github.com/apache/lucene-solr/tree/master/lucene/analysis/common/src/java/org/apache/lucene/analysis/en
     -->

    <!ENTITY use_stemmer_dictionary '
     <filter class="solr.KeywordMarkerFilterFactory" protected="schema/stemming/stemmer_overrides/e_exception_words.txt" />
     <filter class="solr.KeywordMarkerFilterFactory" protected="schema/stemming/stemmer_overrides/proper_nouns.txt" />
     <filter class="solr.KeywordMarkerFilterFactory" protected="schema/stemming/stemmer_overrides/dict_supplement.txt" />

      <filter class="solr.StemmerOverrideFilterFactory" dictionary="schema/stemming/stemmer_overrides/country_nationality.txt" />
      <filter class="solr.StemmerOverrideFilterFactory" dictionary="schema/stemming/stemmer_overrides/direct_conflations.txt" />
    '>

    <!ENTITY stem_with_porter_stemmer '
      <filter class="solr.PorterStemFilterFactory"/>
    '>

    <!ENTITY stem_with_kstemmer '
        &use_stemmer_dictionary;
        <filter class="solr.KStemFilterFactory"/>
    '>

    <!ENTITY deal_with_english_possives_in_absense_of_stemming '
      <filter class="solr.EnglishPossessiveFilterFactory"/>
    '>

    <!-- (De)duplication and Synonyms  -->


    <!ENTITY overlay_token_copies_for_later_processing '
      <filter class="solr.KeywordRepeatFilterFactory"/>
    '>


    <!ENTITY remove_duplicates_at_same_position '
      <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
    '>

    <!ENTITY expand_synonyms_at_query_time '
        <filter class="solr.SynonymGraphFilterFactory" synonyms="schema/synonyms.txt" ignoreCase="true" expand="true"/>

    '>

    <!-- Normalization and case folding -->

    <!ENTITY try_to_deal_with_cjk '
      <filter class="solr.CJKWidthFilterFactory"/>
      <filter class="solr.CJKBigramFilterFactory"
        han="true" hiragana="true  "
        katakana="false" hangul="false"
        outputUnigrams="false"
      />
    '>

    <!ENTITY pre_tokenization_case_folding '
      <charFilter class="solr.ICUNormalizer2CharFilterFactory"/>
    '>

    <!ENTITY icu_case_folding_and_normalization '
      <filter class="solr.ICUFoldingFilterFactory"/>
    '>

    <!ENTITY keyword_aware_icu_case_folding_and_normalization '
      <filter class="edu.umich.lib.solr_filters.KeywordAwareICUFoldingFilterFactory"/>
    '>

    <!-- Tokenizing -->
    <!ENTITY tokenize_with_icu '
      <tokenizer class="solr.ICUTokenizerFactory"/>
    '>

    <!ENTITY tokenize_on_slash '
      <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/"/>
    '>

    <!ENTITY tokenize_into_one_big_token '
      <tokenizer class="solr.KeywordTokenizerFactory"/>
    '>


    <!-- Some useful repeated chains -->


    <!ENTITY standard_tokenization '
      &pre_tokenization_case_folding;
      &pre_tokenization_character_substitution;
      &tokenize_with_icu;
      &trim_leading_and_trailing_whitespace;
      &normalize_numeric_digits;
     '>

    <!ENTITY standard_single_token_tokenizer '
      &pre_tokenization_case_folding;
      &pre_tokenization_character_substitution;
      &tokenize_into_one_big_token;
      &trim_leading_and_trailing_whitespace;
      &keyword_aware_icu_case_folding_and_normalization;
      &normalize_numeric_digits;
    '>

    ]>


<schema name="library_solr_config" version="1.6">
    <!-- attribute "name" is the name of this schema and is only used for display purposes.
         version="x.y" is Solr's version number for the schema syntax and
         semantics.  It should not normally be changed by applications.

         1.0: multiValued attribute did not exist, all fields are multiValued
              by nature
         1.1: multiValued attribute introduced, false by default
         1.2: omitTermFreqAndPositions attribute introduced, true by default
              except for text fields.
         1.3: removed optional field compress feature
         1.4: autoGeneratePhraseQueries attribute introduced to drive QueryParser
              behavior when a single string produces multiple tokens.  Defaults
              to off for version >= 1.4
         1.5: omitNorms defaults to true for primitive field types
              (int, float, boolean, string...)
         1.6: useDocValuesAsStored defaults to true.
    -->


    <!-- Load up the primative field types -->
    &primative_types;


    <!-- load up any local additions -->
    &local_fieldtypes;
    &local_dynamic_fields;
    &local_explicit_fields;

    <!-- define a basic, forgiving text type with stemming and synonyms

    We only expand synonyms at query time, since we don't need them  in both

    -->

    <fieldType name="text" class="solr.TextField"
               positionIncrementGap="&pig;">
        <analyzer type="index">
            &standard_tokenization;
            &stem;
            &keyword_aware_icu_case_folding_and_normalization;
            &try_to_deal_with_cjk;
            &remove_duplicates_at_same_position;
        </analyzer>
        <analyzer type="query">
            &standard_tokenization;
            &expand_synonyms_at_query_time;
            &stem;
            &overlay_token_copies_for_later_processing;
            &keyword_aware_icu_case_folding_and_normalization;
            &try_to_deal_with_cjk;
            &remove_duplicates_at_same_position;
        </analyzer>
    </fieldType>

    <!-- Without stemming or synonyms is basically the same thing -->
    <fieldType name="text_no_stem_or_synonyms" class="solr.TextField"
               positionIncrementGap="&pig;">
        <analyzer>
            &standard_tokenization;
            &try_to_deal_with_cjk;
            &remove_duplicates_at_same_position;
        </analyzer>
    </fieldType>

    <!-- an "exact" match, allowing for simple char substitutions and case/diacritic folding -->

    <fieldType name="exactish" class="solr.TextField"
               positionIncrementGap="&pig;">
        <analyzer>
            &standard_single_token_tokenizer;
            &spaceify_dash_and_colon;
            &remove_all_punctuation;
            &trim_leading_and_trailing_whitespace;
            &overlay_token_copies_for_later_processing;
            &keyword_aware_icu_case_folding_and_normalization;
        </analyzer>
    </fieldType>

    <!-- Only left-anchored matches -->
    <fieldType name="text_leftanchored" class="solr.TextField"
               positionIncrementGap="&pig;">
        <analyzer>
            &pre_tokenization_case_folding;
            &pre_tokenization_character_substitution;
            &tokenize_with_icu;
            &stem;
            &overlay_token_copies_for_later_processing;
            &keyword_aware_icu_case_folding_and_normalization;
            &try_to_deal_with_cjk;
            <filter class="edu.umich.lib.solr_filters.LeftAnchorifyFilterFactory"/>
            &remove_duplicates_at_same_position;
        </analyzer>
    </fieldType>


    <!-- Valid attributes for fields:
      name: mandatory - the name for the field
      type: mandatory - the name of a field type from the
        <types> fieldType section
      indexed: true if this field should be indexed (searchable or sortable)
      stored: true if this field should be retrievable
      docValues: true if this field should have doc values. Doc values are
        useful for faceting, grouping, sorting and function queries. Although not
        required, doc values will make the index faster to load, more
        NRT-friendly and more memory-efficient. They however come with some
        limitations: they are currently only supported by StrField, UUIDField
        and all Trie*Fields, and depending on the field type, they might
        require the field to be single-valued, be required or have a default
        value (check the documentation of the field type you're interested in
        for more information)
      multiValued: true if this field may contain multiple values per document
      omitNorms: (expert) set to true to omit the norms associated with
        this field (this disables length normalization and index-time
        boosting for the field, and saves some memory).  Only full-text
        fields or fields that need an index-time boost need norms.
        Norms are omitted for primitive (non-analyzed) types by default.
      termVectors: [false] set to true to store the term vector for a
        given field.
        When using MoreLikeThis, fields used for similarity should be
        stored for best performance.
      termPositions: Store position information with the term vector.
        This will increase storage costs.
      termOffsets: Store offset information with the term vector. This
        will increase storage costs.
      required: The field is required.  It will throw an error if the
        value does not exist
      default: a value that should be used if no value is specified
        when adding a document.
    -->


    <similarity
        class="org.apache.lucene.search.similarities.BM25Similarity"/>


    <!-- If you remove this field, you must _also_ disable the update log in solrconfig.xml
       or Solr won't start. _version_ and update log are required for SolrCloud
    -->
    <field name="_version_" type="long" indexed="true" stored="false"
           multiValued="false"/>

    <!-- points to the root document of a block of nested documents. Required for nested
       document support, may be removed otherwise
    -->
    <field name="_root_" type="string" indexed="true" stored="false"
           docValues="false"/>

    <!-- Only remove the "id" field if you have a very good reason to. While not strictly
      required, it is highly recommended. A <uniqueKey> is present in almost all Solr
      installations. See the <uniqueKey> declaration below where <uniqueKey> is set to "id".
      Do NOT change the type and apply index-time analysis to the <uniqueKey> as it will likely
      make routing in SolrCloud and document replacement in general fail. Limited _query_ time
      analysis is possible as long as the indexing process is guaranteed to index the term
      in a compatible way. Any analysis applied to the <uniqueKey> should _not_ produce multiple
      tokens
    -->
    <field name="id" type="&id_type;" indexed="true" stored="&id_stored;"
           required="true"
           multiValued="false"/>

    <field name="tla" type="text_leftanchored" indexed="true" stored="true"/>
    <field name="t" type="text" indexed="true" stored="true"/>
    <field name="e" type="exactish" indexed="true" stored="true"/>
    <copyField source="t" dest="tla"/>
    <copyField source="t" dest="e"/>

    <!-- Field to use to determine and enforce document uniqueness.
         Unless this field is marked with required="false", it will be a required field
      -->
    <uniqueKey>id</uniqueKey>


</schema>
